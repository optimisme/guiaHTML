<!DOCTYPE html>
<html lang="ca" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="UTF-8" />
    <title>Funcions de transició — demos + gràfic per tipus</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #ffffff;
        --text: #000000;
        --muted: #444;
        --track: #ededed;
        --border: #000; /* només per a gràfics */
        --box: #1976d2;
        --graph-line: #8b0000;
        --dot: #ff0000;
      }
      html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
      header { padding: 16px 20px 8px; }
      h1 { margin: 0 0 6px 0; font-size: 18px; }
      p { margin: 0; color: var(--muted); }
      .toolbar { display: flex; justify-content: flex-end; gap: 10px; align-items: center; padding: 8px 20px 14px; }
      button { background: #f5f5f5; color: var(--text); border: 1px solid #aaa; border-radius: 8px; padding: 8px 12px; cursor: pointer; }
      button:disabled { opacity: 0.5; cursor: default; }

      /* columns: label | example | graph (més estreta encara) */
      .grid { display: grid; grid-template-columns: 220px 1fr 0.26fr; gap: 14px; padding: 0 20px 16px; }
      .row { display: contents; }
      .cell { padding: 8px 0; }
      .label strong { display: block; font-size: 16px; }
      .label code { color: #333; }

      /* Pista: sense arrodonits ni relleu/borde negre */
      .track { position: relative; height: 56px; background: var(--track); border: none; border-radius: 0; }
      .block { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 26px; height: 26px; background: var(--box); border: 1px solid #003; border-radius: 4px; z-index: 10; }

      .gwrap { position: relative; }
      canvas.graph { width: 100%; aspect-ratio: 1 / 1; display: block; background: #fff; border: 1px solid var(--border); border-radius: 6px; max-width: 75px; }
      .legend { font-size: 12px; color: #000; margin-top: 4px; }
    </style> 
  </head>
  <body>
    <header>
      <h1>Funcions de transició (easings)</h1>
    </header>
    <div class="toolbar">
      <button id="btnPlay">Play</button>
      <span style="margin-left:8px;color:#000">Durada 2s</span>
    </div>

    <div id="grid" class="grid"></div>

    <script>
      function cubicBezier(p1x,p1y,p2x,p2y){
        const cx=3*p1x, bx=3*(p2x-p1x)-cx, ax=1-cx-bx;
        const cy=3*p1y, by=3*(p2y-p1y)-cy, ay=1-cy-by;
        const sampleX=t=>((ax*t+bx)*t+cx)*t;
        const sampleXd=t=>(3*ax*t+2*bx)*t+cx;
        const sampleY=t=>((ay*t+by)*t+cy)*t;
        function solveT(x){ let t=x; for(let i=0;i<5;i++){ const xEst=sampleX(t)-x, d=sampleXd(t); if(Math.abs(xEst)<1e-6) return t; if(Math.abs(d)<1e-6) break; t-=xEst/d; } let t0=0,t1=1; t=x; while(t0<t1){ const xEst=sampleX(t); if(Math.abs(xEst-x)<1e-6) return t; if(x>xEst) t0=t; else t1=t; t=0.5*(t0+t1); if(t1-t0<1e-6) break;} return t; }
        return x=>{ if(x<=0) return 0; if(x>=1) return 1; return sampleY(solveT(x)); };
      }

      // Bounce aproximat amb CSS linear() → aquí l\'implementem com a taula mostrejada
      function linearBounce(x) {
        const keyframes = [
          0, 0.004, 0.016, 0.035, 0.063, 0.091, 0.141, 0.25, 0.391, 0.563, 0.765, 1,
          0.891, 0.813, 0.785, 0.766, 0.754, 0.75, 0.754, 0.766, 0.785, 0.813, 0.891, 1,
          0.973, 0.953, 0.941, 0.938, 0.941, 0.953, 0.973, 1,
          0.988, 0.984, 0.988, 1
        ];
        const n = keyframes.length - 1; const pos = x * n; const i = Math.floor(pos); const f = pos - i;
        return i < n ? keyframes[i] + (keyframes[i + 1] - keyframes[i]) * f : 1;
      }

      const Easings = {
        linear: x => x,
        ease: cubicBezier(0.25, 0.10, 0.25, 1.00),
        easeIn: cubicBezier(0.42, 0.00, 1.00, 1.00),
        easeOut: cubicBezier(0.00, 0.00, 0.58, 1.00),
        easeInOut: cubicBezier(0.42, 0.00, 0.58, 1.00),
        bounce: linearBounce
      };

      const ROWS = [
        { key: 'linear', label: 'linear', bez: 'cubic-bezier(0.00, 0.00, 1.00, 1.00)', fn: Easings.linear },
        { key: 'ease', label: 'ease', bez: 'cubic-bezier(0.25, 0.10, 0.25, 1.00)', fn: Easings.ease },
        { key: 'easeIn', label: 'ease-in', bez: 'cubic-bezier(0.42, 0.00, 1.00, 1.00)', fn: Easings.easeIn },
        { key: 'easeOut', label: 'ease-out', bez: 'cubic-bezier(0.00, 0.00, 0.58, 1.00)', fn: Easings.easeOut },
        { key: 'easeInOut', label: 'ease-in-out', bez: 'cubic-bezier(0.42, 0.00, 0.58, 1.00)', fn: Easings.easeInOut },
        // Bounce només mostra subtext amb el seu linear(...) real
        { key: 'bounce', label: 'bounce', bez: 'linear(0, 0.004, 0.016, 0.035, 0.063, 0.091, 0.141, 0.25, 0.391, 0.563, 0.765, 1, 0.891, 0.813, 0.785, 0.766, 0.754, 0.75, 0.754, 0.766, 0.785, 0.813, 0.891, 1, 0.973, 0.953, 0.941, 0.938, 0.941, 0.953, 0.973, 1, 0.988, 0.984, 0.988, 1)', fn: Easings.bounce }
      ];

      const grid = document.getElementById('grid');
      const refs = new Map();

      for (const row of ROWS) {
        // Col 1
        const c1 = document.createElement('div'); 
        c1.className = 'cell label';

        const sub = row.key === 'linear'    ? 'moviment constant'
                : row.key === 'ease'      ? 'comença ràpid i frena'
                : row.key === 'easeIn'    ? 'accelera durant el moviment'
                : row.key === 'easeOut'   ? 'frena durant el moviment'
                : row.key === 'easeInOut' ? 'ràpid al punt central i lent als extrems'
                : row.key === 'bounce'    ? 'rebot amb funció personalitzada'
                : '';

        if (row.key === 'bounce') {
        c1.innerHTML = `<strong>${row.label}</strong><div class="sub">${sub}</div><code>${row.bez}</code>`;
        } else {
        c1.innerHTML = `<strong>${row.label}</strong><div class="sub">${sub}</div>`;
        }
        // Col 2
        const c2 = document.createElement('div'); c2.className = 'cell';
        const track = document.createElement('div'); track.className = 'track';
        const block = document.createElement('div'); block.className = 'block';
        track.appendChild(block); c2.appendChild(track);
        // Col 3
        const c3 = document.createElement('div'); c3.className = 'cell gwrap';
        const canvas = document.createElement('canvas'); canvas.className = 'graph';
        const legend = document.createElement('div'); legend.className = 'legend';
        if (row.key === 'bounce') legend.textContent = '(X: temps, Y: valor)';
        c3.appendChild(canvas); if (row.key === 'bounce') c3.appendChild(legend);
        // Fila
        const rowWrap = document.createElement('div'); rowWrap.className = 'row';
        rowWrap.appendChild(c1); rowWrap.appendChild(c2); rowWrap.appendChild(c3);
        grid.appendChild(rowWrap);
        refs.set(row.key, { track, block, canvas, ctx: canvas.getContext('2d'), fn: row.fn });
      }

      function fitCanvas(canvas){
        const ratio = window.devicePixelRatio || 1;
        const displayWidth = Math.floor(canvas.clientWidth * ratio);
        const displayHeight = Math.floor(canvas.clientHeight * ratio);
        if(canvas.width !== displayWidth || canvas.height !== displayHeight){ canvas.width = displayWidth; canvas.height = displayHeight; }
      }

      function drawGraph(ctx, fn, t){
        const W = ctx.canvas.width, H = ctx.canvas.height;
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; // marc i eixos
        ctx.strokeRect(0.5,0.5,W-1,H-1);
        const pad = 5 * (window.devicePixelRatio||1);
        const gx = pad, gy = pad, gw = W - pad*2, gh = H - pad*2;
        ctx.beginPath();
        ctx.moveTo(gx, gy + gh); ctx.lineTo(gx + gw, gy + gh); // X
        ctx.moveTo(gx, gy);      ctx.lineTo(gx, gy + gh);      // Y
        ctx.stroke();
        // Corba
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-line').trim() || '#8b0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0;i<=gw;i++){
          const x01 = i / gw; const y01 = 1 - clamp01(fn(x01));
          const px = gx + i; const py = gy + y01 * gh;
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
        // Punt
        const ex = clamp01(t); const ey = clamp01(fn(ex));
        const px = gx + ex * gw; const py = gy + (1 - ey) * gh;
        ctx.beginPath(); ctx.arc(px, py, 5*(window.devicePixelRatio||1), 0, Math.PI*2);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dot').trim() || '#ff0000';
        ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = '#aa0000'; ctx.stroke();
      }

      function clamp01(v){ return v<0?0:v>1?1:v; }

      let start = 0; let animating = false; const duration = 2000;
      const btn = document.getElementById('btnPlay');
      btn.addEventListener('click', () => {
        if(animating) return; animating = true; btn.disabled = true; start = performance.now(); requestAnimationFrame(frame);
      });

      function layoutAndDraw(){ for(const [k,r] of refs) fitCanvas(r.canvas); }
      window.addEventListener('resize', layoutAndDraw);

      function frame(ts){
        const elapsed = ts - start; const t = clamp01(elapsed / duration);
        for(const [key,r] of refs){
          const trackW = r.track.clientWidth; const pad = 12; const x0 = pad; const x1 = trackW - pad; const xRange = x1 - x0;
          const eased = r.fn(t); const x = x0 + eased * xRange; r.block.style.left = x + 'px';
          drawGraph(r.ctx, r.fn, t);
        }
        if(t < 1) requestAnimationFrame(frame); else { animating = false; btn.disabled = false; }
      }

      layoutAndDraw();
    </script>
  </body>
</html>
